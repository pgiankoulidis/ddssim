//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU Lesser General Public License for more details.
// 
// You should have received a copy of the GNU Lesser General Public License
// along with this program.  If not, see http://www.gnu.org/licenses/.
// 

package geomsim;

//========================================================================
//
//	A Dsnet is a simulation model of a distributed stream network.
//  
//	Each Dsnet simulates M methods, each method processing S distributed
//	streams, with each distributed stream consisting of k local streams.
//  The constants M, k and S appear throughout this documentation.
//
//  
//  Each Dsnet has  
//	(a) a  DataSource, which is responsible for generating
//	stream data (e.g., reading from a file), delivered over S*k outputs. 
//	(b) S*k of local streams, responsible for applying filtering and windowing
//	to the data generated by the data source.
//	(c) a broadcaster which simply replicates the local streams to each of the M
//	methods.
//	(c)  a collection of M methods, where each method consists of 
//		(c1) k local sites, each accepting S local streams, and
//		(c2) a coordinator
//
//	Technical note: modules have gate arrays, with connections corresponding to
//  local streams. 
//
//=========================================================================

//
//  A data source generates all the distributed stream data.
//  In particular, it outputs one connection for each local stream
//
moduleinterface IDataSource
{
    parameters:
        int streams;
        int sites;
    gates:
        output local_stream[streams*sites];
}
simple DataSource like IDataSource
{
	parameters:
        int streams;
        int sites;
        @display("i=block/source;is=vl");
    gates:
        output local_stream[streams*sites];
}

//
// A local stream is where processing (windowing, filtering, statistics collection)
// can be done.
//
moduleinterface ILocalStream
{
    parameters:
        int streamID;
        int siteID;

    gates:
        input source;
        output stream;
}
simple LocalStream like ILocalStream
{
    parameters:
        int streamID;
        int siteID;

    gates:
        input source;
        output stream;
}

//
// A local site accepts a S local streams and executes the local protocol
// of a method. 
//
moduleinterface ILocalSite
{
    parameters:
        int siteID;
        int streams;
        @display("i=block/subqueue");
    gates:
        input stream[streams];
        inout coord;
}


simple LocalSite like ILocalSite
{
    parameters:
        int siteID;
        int streams;

        // number of stream updates received
		@signal[protoMsgSent](type=cPacket);
		@signal[protoMsgRecv](type=cPacket);
        @signal[streamRecIn]();
        
        @statistic[streamRecIn](source=count(streamRecIn);record=last);
		@statistic[protoSent](source=protoMsgSent; record=sum(packetBits), count);
		@statistic[protoRecv](source=protoMsgRecv; record=sum(packetBits), count);

    gates:
        input stream[streams];
        inout coord;
}

//
// A coordinator connects with k local sites to execute some method
//
moduleinterface ICoordinator
{
	parameters:
        int sites;
        int streams;
        @display("i=device/mainframe");
    gates:
        inout site[sites];
}

simple Coordinator like ICoordinator
{
    parameters:
        int sites;
        int streams;

    gates:
        inout site[sites];
}




//
// A method is composed of k local sites and a coordinator
//
module Method
{
    parameters:

        int sites;
        int streams;

    gates:
        input stream[streams*sites];

    submodules:
        site[sites]: <> like ILocalSite {
            //@display("p=400,0,c;i=misc/node"); 
            siteID = index;
            streams = streams;
        }

        coordinator: <> like ICoordinator {
            //@display("p=600,50;i=device/server"); 
            sites = sites;
            streams = streams;
        }

    connections:
        for i=0..sites-1, for j=0..streams-1 {
            stream[streams*i + j] --> site[i].stream[j];
        }
        for i=0..sites-1 {
            site[i].coord <--> coordinator.site[i];
        }
}


//	The StreamBroadcaster is just a copying module, whose job is to
//	multiplex k*S local streams to M*k*S outgoing connections. This is done
//	in order to feed the k*S incoming connections of each of M methods.

simple StreamBroadcaster
{
    parameters:
        int streams;
        int sites;
        int methods;
        @display("i=abstract/dispatcher");
    gates:
        input stream[streams*sites];
        output methstream[streams*sites*methods];
}

//
//	The Dsnet is a network module bringing together all the modules of a simulation.
//	The most important part of the definition is in the connections section, where the
//    correspondence of connections between modules is defined.
//
network Dsnet
{
    int streams = default(1);
    int sites;
    int methods;

    string sourceType;

    submodules:
        source: <sourceType> like IDataSource {
            @display("p=0,50;i=block/source");
            streams = streams;
            sites = sites;
        }

        stream[streams*sites]: <> like ILocalStream {
            @display("p=200,0,c;i=block/boundedqueue");

            streamID = index % streams;
            siteID = index / streams;
        }

        bcaster: StreamBroadcaster {
            streams = streams;
            sites = sites;
            methods = methods;
        }

        method[methods]: Method {
            @display("p=500,0,c;i=block/network");
            sites = sites;
            streams = streams;
        }

    connections:

        // Connect data source to local streams and to broadcaster
        for i=0..sites-1, for j=0..streams-1 {
            source.local_stream[i*streams + j] --> stream[i*streams+j].source;
            stream[i*streams+j].stream --> bcaster.stream[i*streams+j];

        }

		// broadcaster to methods
        for m=0..methods-1, for i=0..sites-1, for j=0..streams-1 {
            bcaster.methstream[m*sites*streams + i*streams + j] --> method[m].stream[i*streams+j];
        }

}


//============================================================================
//
//  Basic component library
//
//	Here, some concrete implementations of the above definitions are provided.
//
//============================================================================



//
// This module is a data source for simple-minded synthetic workloads.
// It creates data as uniformly random integers in [0: domainSize).
// The sendInterval refers to simulation time between samples. 
// The streamLength is the number of elements in all the streams.  
//
simple SimpleSyntheticDataSource extends DataSource
{
	@class(SimpleSyntheticDataSource);
    int domainSize = default(65536);
    volatile double sendInterval @unit(s) = default(exponential(1s));
    int totalStreamLength = default(1000); // one million stream tuples total
}


//
// This local stream simply propagates its input to the output
//
simple PropagatingLocalStream extends LocalStream
{
    @class(PropagatingLocalStream);
}


//
// This local stream defines sliding window containing
// all records received during the last T seconds.
//
simple SlidingWindowLocalStream extends LocalStream
{
	@class(SlidingWindowLocalStream);
    double windowTime @unit(s);
    
    @signal[wsize](type=unsigned long);
    @statistic[wsize](record=max,timeavg,vector?);
}

//
// This local stream defines a fixed-size buffer to
// act as a sliding window
//
simple SlidingBufferLocalStream extends LocalStream
{
    @class(SlidingBufferLocalStream);
    int windowSize;

    @signal[winterval](type=simtime_t);
    @statistic[winterval](record=max,timeavg,vector?);
}




//
// The naive local site just forwards its inputs to the coordinator
//
simple NaiveLocalSite extends LocalSite
{
	@class(NaiveLocalSite);
}


//
// The naive coordinator simply accepts raw local streams from the
// sites. It computes statistics of the inputs.
//
simple NaiveCoordinator extends Coordinator
{
    @class(NaiveCoordinator);
}




